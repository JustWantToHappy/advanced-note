## yarn
### 优缺点

- 优点：离线模式，并行下载，锁定版本号
- yarn全局缓存：保存了从互联网下载的依赖项的二进制文件和元数据(保存的是压缩文件，不同于node_modules中的解压后的文件)
- 锁定版本文件:yarn.lock
## npm
### 优缺点
npm在5.x.x版本中引入了package-lock.json，也支持版本锁定

- 缺点：npm安装包是串行的，如果中间某个包的安装出现错误，npm不会停止，而是会继续安装，这就会导致如果后面还有错误的话，最头上的错误将难以排查。
- 版本锁定文件:package-lock.json
### 相关命令
- 查看当前所有镜像：npm 
- 设置镜像：npm config set registry 镜像地址
- 使用nrm管理镜像源：
   - 下载nrm:npm install -g nrm
   - nrm ls:显示当前可用的镜像源
- npm get registry:获取当前配置npm的注册表的url
- nrm use 镜像名称：切换镜像地址
## pnpm

- 优点：
   - 存储空间：pnpm使用硬链接和符号链接来保存存储空间，相比之下，npm和yarn在安装依赖的时候会将每个包都复制到项目的node_modules目录中，这会占用更多磁盘空间，pnpm利用链接的方式来共享包，因此可以显著减少磁盘空间的占用。
   - 并行安装：pnpm使用并行安装依赖项，这意味着可以在同一个命令中同时安装多个依赖项，从而提高安装速度
   - 包隔离：pnpm有一个严格的包隔离机制，这意味着每个项目都有自己的node_modules目录，并且不会看到其他项目的依赖关系，这可以避免包之间的冲突和版本问题
   - 兼容性：pnpm兼容npm或yarn的包管理器，这意味着你可以在已有的npm或者yarn项目中使用pnpm，而不需要修改项目配置文件或更改依赖的方式。
   - 版本锁定文件:pnpm-lock.yarm
- 注意点：对于同一依赖包的不同版本，pnpm也只是会去下载不同依赖包的不同文件，相同文件之前已经下载过了，就不需要下载了。
## 语义化版本规范
X.Y.Z=主版本.次版本.修订版
- 1.0.0=>2.0.0(破坏性升级)
- 1.0.0=>1.1.0(向后兼容升级)
- 1.0.0=>1.0.1(bug修复)
<br>

<strong>不稳定版本定义</strong>
- 1.0.0-alpha
- 1.0.0-rc.1
- 1.0.0-0.3.7
<br>

<b>优先级规则</b>
- 1.0.0小于2.0.0小于2.1.0
- 1.0.0-alpha小于1.0.0-alpha.1小于1.0.0-beta.1
- 2.0.0-beta小于2.0.0小于3.0.0-beta
<br>

## 版本范围
> 其中在package.json中书写的版本号，官方定义为版本范围

## 版本依赖符号
- ~：波浪号前缀告诉包管理器允许安装与指定版本相同的主版本号以及次版本号，，但不包括指定版本的补丁版本（patch version）。例如，如果你定义了依赖 "package-name": "~1.2.3"，包管理工具将允许安装 1.2.3、1.2.4、1.2.5，但不会允许安装 1.3.0 或更高的版本。
- ^（插入符号）：插入符号前缀表示允许安装与指定版本兼容的所有版本，包括主版本号（major version）不同的新版本。例如，如果你定义了依赖 "package-name": "^1.2.3"，包管理工具将允许安装 1.2.3、1.2.4、1.2.5、1.3.0 以及更高的版本。(tips: 如果发布的包主版本是0，这意味着该依赖是不稳定的，比如发布最新的包为0.2.0，我们的deps中是^0.1.0，重新安装也不会安装0.2.0，等同于^0.1.0===~0.1.0)

## 对等依赖Dependencies 
- 共享版本：peerDependencies确保子项目和父项目使用同一版本的 react，避免多个版本同时加载的错误
- 用户需要显式安装 peerDependencies 声明的依赖
- 非常适合插件系统（如 React、Vue、Webpack 插件等），这些插件需要运行在相同的主框架版本上

## 幻影依赖
如果不使用pnpm管理monoorepo，而是使用npm or yarn classic方式管理monorepo，因为依赖扁平化的原因，导致了一个问题：比如a包依赖b包，而b包依赖loadash，因为依赖在node_modules中的扁平化，a包也可以import loadash，而哪一天b包中的loadash改成了lodash/es或者替换成其他包，这会导致a包中找不到loadash
