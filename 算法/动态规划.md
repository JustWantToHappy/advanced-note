# 动态规划
如果某一问题有很多重叠子问题，使用动态规划是最有效的

动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的

dp五部曲：
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

# 01背包问题
> 每个物品只能使用一次

题目：有N个物品和一个容器为V的背包，第i件物品的体积为c[i],价值为w[i],求将物品装入背包可以使价值总和最大是多少？

定义状态：即f[i][v]表示前i件物品中选取一些物品恰放入一个容量为v的背包可以获取的最大价值，则其状态转移方程为:
`f[i][v]=Max(f[i-1][v],f[i-1][v-c[i]]+w[i])`

解释：如果不放第i件物品，则价值为f[i-1][v]，如果放第i件物品，则问题将转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，价值为f[i-1][v-c[i]]

进一步优化空间，使用一维滚动数组:dp[j]=Max(dp[j],dp[j-c[i]]+w[i])

```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```
为什么上面的滚动数组写法背包要写成倒序，而不能写成正序，这是因为如果是正序，那么在本轮i循环中，物品i会被放多次

举个例子，比比如只有一个物品，物品0重量为1,价值为1，那么背包容量为1会放一次dp[1]=1，dp[2]又会放一次，dp[2]=max(dp[2],dp[2-1]+1),也就是dp[1]+1=2,容量为1放过一次，这里再放一次。

而如果是倒序，那这里dp[2]=dp[1]+1=1,因为dp[1]初始值为0，这样就不可能让同一件物品在同一背包容量中出现多次

https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E6%80%9D%E8%B7%AF

# 完全背包问题
> 每个物品可以使用无限次

题目：有N个物品和一个容器为V的背包，第i件物品的体积为c[i],价值为w[i],求将物品装入背包可以使价值总和最大是多少？
根据01背包的思路写出状迁移方程：

`dp[i][v]=Max(dp[i-1][v],dp[i-1][v-k*c[i]]+k*w[i])`

解释：对于第i件物品，如果我们没有选择，则最大价值就是前i个商品凑出来的最大价值(即dp[i-1][v]，如果选择了第i个商品，这个商品我们可能选择了k个(即dp[i-1][v-k*c[i]]+k*w[i])

对于以上状态转移方程，经过一系列转换后，可以得到这样一个状态方程:
`dp[i][v]=Max(dp[i-1][v],dp[i][v-c[i]]+w[i]`打表就容易知道dp[i][v]的值是由上方or左方推导而出

对于此方程，我们可以优化dp的空间，使用一维的状态转移方程：

`dp[i]=Max(dp[i],dp[v-c[i]]+w[i])`

https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85

> 是否先遍历背包容量还是遍历物品，是否倒序还是正序遍历需根据题目具体分析

## 树形dp
经典树形dp问题：https://leetcode.cn/problems/house-robber-iii/description/

解法：
```javascript
	const arr1 = [3, 2, 3, null, 3, null, 1] //预期结果7
	const arr2 = [3, 4, 5, 1, 3, null, 1]//预期结果9

	const backtracking = (arr = [], index = 0) => {
		if (index >= arr.length || !arr[index]) {
			//每个节点都有两种状态，[0]表示不放当前值，[1]表示放当前值
			return [0, 0]
		}
		const [l1, r1] = backtracking(arr, index * 2 + 1)
		const [l2, r2] = backtracking(arr, index * 2 + 2)
		return [Math.max(l1, r1) + Math.max(l2, r2), arr[index] + l1 + l2]
	}

	console.log(Math.max(...backtracking(arr1)));
	console.log(Math.max(...backtracking(arr2)));
```