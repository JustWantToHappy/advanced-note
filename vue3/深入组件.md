## 组件注册
### 全局注册
我们可以使用 Vue 应用实例的 .component() 方法，让组件在当前 Vue 应用中全局可用。
```javascript
app
  .component('ComponentA', ComponentA)
  .component('ComponentB', ComponentB)
  .component('ComponentC', ComponentC)
```
### 局部注册
就是使用的时候import
## props声明
一个组件需要显式声明它所接受的props，这样vue才能够知道外部传入的是哪些props
- 在使用了`setup`的单文件组件中，props可以通过`defineProps()`宏来声明
```html 
<script setup>
const props = defineProps(['foo'])

console.log(props.foo)
</script>
```
```html
- 在没有使用`<script setup/>`的组件中，props可以通过`props`选项来声明
```javascript
export default {
    props:["foo"],
    setup(props){
        console.info(props.foo)
    }
}
```
- 除了使用字符串数组的形式来声明props外，还可以通过使用对象的形式来证明
```javascript
//使用setup
defineProps({title:String,likes:Number})
```
ts版本如下
```html
<script setup lang="ts">
//使用setup
defineProps<{
  title?: string
  likes?: number
}>()
</script>
```
```javascript
//非setup
export default {
    props:{
        title:String;
        likes:Number;
    }
}
```
### 单向数据流
所有的props都遵循**单向绑定**原则，props因父组件的更新而变化
```javascript
const props = defineProps(['foo'])

// ❌ 警告！prop 是只读的！
props.foo = 'bar'
```
导致你想要更改props的需求通常源于以下两种场景
1. **props被用于传入初始值，在子组件想要在之后将其作为一个局部数据属性**
```javascript
const props = defineProps(['initialCounter'])

// 计数器只是将 props.initialCounter 作为初始值
// 像下面这样做就使 prop 和后续更新无关了
const counter = ref(props.initialCounter)
```
2. **需要传入一个props值做进一步的转换**
```javascript
const props = defineProps(['size'])

// 该 prop 变更时计算属性也会自动更新
const normalizedSize = computed(() => props.size.trim().toLowerCase())
```
### props校验
vue组件可以更加细致地声明对传入的props的校验要求，这在开发给其他开发者使用的组件时非常有用
```html
<script lang="ts" setup>
defineProps({
	type: {
		type: String,
		required: true,
		validator(type: any) {
			return ["default", "primary", "text", "link"].includes(type)
		}
	}
})
</script>
<script lang="ts">
import { defineComponent } from "vue";
export default defineComponent({
	name: "HelloWorld",
});
</script>
<template>
	<div>
		{{ type }}
	</div>
</template>

```
- `defineProps()`宏中的参数不能够访问`<script setup/>`中定义的其他变量
- 所有props都是可选的，除非声明了`required:true`
- 除`Boolean`外未传递的可选props将会有一个默认值`undefined`
- `Boolean`类型未传递props将会被转换为`false`
## 事件
### 事件参数
> 我们可以给$emit提供一个额外的参数，注意的是$emit只能够在`template`模板中使用
```html
<button @click="$emit('increaseBy', 1)">
  Increase by 1
</button>
```
然后我们在父组件中监听事件，我们可以简写一个内联的箭头函数作为监听器
```html
<MyButton @increase-by="(n) => count += n" />
```
### 声明触发的事件
组件可以显示通过`defineEmits()`宏来声明它要触发的事件,注意：`defineEmits()`宏不能够在子函数中调用，它必须放置在`<script setup/>`的顶级作用域下
```html
<script setup>
defineEmits(['inFocus', 'submit'])
</script>
```
使用setup函数的情况下
```javascript
export default{
  emits:["inFocus","submit"],
  setup(props,{emit}){

  }
}
```
ts下使用方式
```html
//第一种方式
<script setup lang="ts">
//自定义change事件与update事件的声明
const emit = defineEmits<{
  (e: 'change', id: number): void
  (e: 'update', value: string): void
}>()
</script>
//第二种方式
<script>
  const emit = defineEmits<{
  change: [id: number]
  update: [value: string]
}>()
</script>
```
### 事件校验
和与props添加类型校验的方式类似
```html
<script setup>
const emit = defineEmits({
  // 没有校验
  click: null,

  // 校验 submit 事件
  submit: ({ email, password }) => {
    if (email && password) {
      return true
    } else {
      console.warn('Invalid submit event payload!')
      return false
    }
  }
})

function submitForm(email, password) {
  emit('submit', { email, password })
}
</script>
```
## 组件v-model
`v-model`可以在组件上使用实现双向绑定,如果想要使用，得在vite.config配置文件中添加如下代码
```javascript
export default defineConfig({
  plugins: [
		vue({
			script: {
				defineModel:true
			}
		}),
	],
```
### 基本用法
```html
<!--HelloWorld.vue-->
<script lang="ts" setup>
const model = defineModel<number>()
const update = () => model.value++;
</script>
<template>
	<button v-on:click="update">点击</button>
</template>

```
父组件可以使用`v-model`绑定一个值
```html
<script lang="ts" setup>
import { ref } from "vue"
const count = ref(0)
</script>
<template>
	<ul>
		{{ count }}
		<HelloWorld v-model="count" />
	</ul>
</template>
```
不使用defineModel手动实现一个双向绑定
```html
<!--父组件-->
<script lang='ts' setup>
import { ref } from "vue"
const input = ref<string>();
const modifyInput = (value: string) => input.value = value;
</script>

<template>
	<div>
		<span>{{ input }}</span>
		<HelloWorld v-bind:input="input" @modify-input="modifyInput" />
	</div>
</template>
```
```html
<!--HelloWorld.vue-->
<script lang="ts" setup>
defineProps<{ input: string }>()
defineEmits<{ (e: "modify-input", value: string): void }>()
</script>
<template>
	<input :value="input" @input="$emit('modify-input', $event.target.value)" />
</template>

```
### 多个v-model的绑定
```html
<UserName
  v-model:first-name="first"
  v-model:last-name="last"
/>
```
```html
<script setup>
const firstName = defineModel('firstName',{required:true})
const lastName = defineModel('lastName',{default:"Mark"})
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
</template>
```
### 处理`v-model`修饰符