## 虚拟内存地址
- 我们程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address）
- 实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）
出现虚拟内存地址的背景是为了防止两个不同程序使用同一物理内存地址，加了个中间层

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关关系，来转换变成物理地址，然后再通过物理地址访问内存
![alt text](image-16.png)

## 内存分段
操作系统是如何管理虚拟地址与物理地址之间的关系？

程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来

### 内存分段的问题
- 内存碎片
举个例子：比如我们的浏览器应用程序占用128MB的内存，释放掉之后，我们想要启动一个占用内存200mb的程序就没办法做到，虽然有两个128MB的空闲内存，但是是不连续的
![alt text](image-17.png)
- 内存交换的效率低

而内存交换效率低是因为我们可以将部分内存写到硬盘上，这样就可以解决上面例子中的问题，比如将例子中的音乐占用的内存写到硬盘，这样重新分配内存空间的位置，这个内存交换空间，在Linux系统中，也就是我们经常看到的Swap空间，这块空间是硬盘划分出来的，用于内存与硬盘的空间交换

为了解决上面的问题，于是出现了内存分页

## 内存分页
分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page），在 Linux 下，每一页的大小为 4KB
![alt text](image-18.png)

页表是存储在内存里的，内存管理单元 （MMU）就做将虚拟内存地址转换成物理地址的工作。

分页是如何解决内存碎片以及内存交换效率低的问题的？

- 内存碎片解决方案：页与页之间是紧密相排的，因为内存分页机制分配内存的最小单位是页，所有不会有外部碎片，但是如果程序大小不足一页，我们最少还是得分配一页的内存大小，所有会有内存碎片的问题
- 内存交换效率低解决方案：一次性写入磁盘的也只有少数的一个页或者几个页，不会花费太多的时间，内存交换效率比较高
- 只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去：这句话怎么理解，当 CPU 第一次访问某个虚拟页里的代码或数据时，如果它还不在内存，就触发缺页异常，由操作系统从磁盘把这一页加载到物理内存,比如如下这段代码，只有运行之后才会加载对应的内存，可以理解为按需加载
```c
if (debug) {
    printHugeDebugInfo(); // 你从没打开 debug
}
```

## 多级页表
如下是简单分页的图例，根据页表，页号+偏移量计算物理内存地址
![alt text](image-19.png)
简单分页会带来一个问题：空间缺陷，比如32位操作系统，物理内存对应的虚拟内存有4个GB,如果页表一页4kb，那么就需要4GB/4KB=1百万个页表示，每个页需要存储虚拟页号，物理页号等数据，也就是每个【页表项目】需要4字节表示，那整个4GB就需要4MB的内存管理页表，因为每个进程是有自己的虚拟地址空间的，那100个进程就需要400MB的内存管理页表

为了解决上面页表占有内存空间大的问题，引入了多级页表
![alt text](image-20.png)

多级页表示如何解决空间缺陷问题的：如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表，即在需要时才创建二级页表。还是上面4GB虚拟内存的例子来理解：如果没有多级，那页表就需要覆盖全部的虚拟空间地址，也就是1百万个页表项，而使用二级页表，我们只需要一级页表1024个，二级页表1024个，因为1024*1024略大于1百万，是可以覆盖所有虚拟内存地址的，由于二级页表是在需要的时候才创建，所有这种方式更节省空间

而如果是64位系统，则使用更多级的页表来表示，其使用的空间将会更少
![alt text](image-21.png)
