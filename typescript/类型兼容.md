## 父子类型
- 在类型系统中，属性更多的类型是子类型
- 在集合论中，属性更少的是子类型
```typescript
type Parent = "a" | "b" | "c";
type Child = "a" | "b";

let parent: Parent;
let child: Child;

// 兼容
parent = child

// 不兼容，因为 parent 可能为 c，而 c 无法 assign 给 "a" | "b"
child = parent

```
```typescript
let parent = new Parent();
const children = new Children();
parent = children;
//children = parent; 错误
```
### extends
extends是一个**条件类型关键字**，下面的代码可以理解为：**如果T是U的子类型，那么结果为X,否则结果为Y**
```typescript
T extends U?X:Y
```
当T是联合类型的时候，叫做分布式条件类型，也就是说当 T 为 "A" | "B" 时， 会拆分成 ("A" extends U ? X : Y) | ("B" extends U ? X : Y)

## 协变和逆变
- **协变**:允许子类型转换为父类型
- **逆变**:允许父类型转换为子类型

上面的例子都是斜边
## 逆变
```typescript
class Animal {}

class Dog extends Animal {
	bark() {}
}

const visitAnimal = (animal: Animal): Dog => {
	return { bark() {} };
};

let visitDog = (dog: Dog): Animal => {
	return {};
};

//visitAnimal = visitDog; 报错
visitDog = visitAnimal;
```
以上代码有点不好理解，可以理解为在visitDog中调用了visitAnimal这个函数：
```typescript
visitDog = (dog: Dog): Animal => {
  // 入参 dog 满足 visitAnimal 入参需要的 Animal 类型
  // 并且 visitAnimal 返回值 dog 包含更多的信息，也符合 visitDog 返回值要求的 Animal 类型
  const dog = visitAnimal(dog);
  return dog;
}
```
## 双向协变
在老版本的TS中，函数参数是双向协变的，也就是说，即可以协变又可以逆变，但是这并不是类型安全的，在新版本 TS (2.6+) 中 ，你可以通过开启 strictFunctionTypes 或 strict 来修复这个问题。设置之后，函数参数就不再是双向协变的了。