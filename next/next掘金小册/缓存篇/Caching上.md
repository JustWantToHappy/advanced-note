## 四种缓存机制
|机制|缓存内容|存储地方|目的|期间|
|----|----|----|----|----|
|请求记忆|函数返回值|服务端|在React组件树中复用数据|每个请求的生命周期|
|数据缓存|数据|服务端|跨用户请求和部署复用数据|持久(可重新验证)|
|完整路由缓存|HTML和RSC payload|服务端|降低渲染成本、提高性能|持久(可重新验证)|
|路由缓存|RSC payload|客服端|减少导航时的服务端请求|用户会话或基于时间|
## 请求记忆
### 工作原理
React扩展了fetch API,当有多个相同的URL和参数的时候，React会自动将请求结果缓存，也就是说，即使你在组件树中的多个位置请求了同一份数据，但是数据的获取只会执行一次<br><br>
这样当你跨路由(比如跨布局、页面、组件)的时候，你无需在顶层请求数据，然后将结果通过Context或者props的方式传递给子组件，直接在需要数据的组件中请求数据即可，无需担心同一数据发出多次请求造成的性能问题<br><br>
关于请求记忆需要关注的点:
- 请求记忆是React的特性，并非next.js的特性，React.js和Next.js都做了请求缓存
- 请求记忆只适合GET方法的fetch请求
- 请求记忆只应用于React组件树，也就是说你在 generateMetadata、generateStaticParams、布局、页面和其他服务端组件中使用 fetch 会触发请求记忆，但是在路由处理程序中使用则不会触发，因为这就不在 React 组件树中了
> 说人话，我觉得就是next层面的React集成了了类似swr的功能
### 持续时间
缓存会持续在服务端请求的生命周期中，直到React组件树渲染完毕。它的存在是为了避免组件树渲染的时候多次请求同一数据造成性能影响
### 重新验证
由于请求记忆只会在渲染期间执行，因此也无需进行重新验证
## 数据缓存
### 工作原理
与React的请求记忆不同的是，请求记忆只用于组件树渲染的时候，所以不用考虑数据缓存更新的情况，但是Next.js的数据缓存方案更加持久
### 持续时间
数据缓存在传入请求和部署中保持不变，除非重新验证或者选择退出
### 重新验证
1. 一种是基于时间的重新验证，即经过一定时间并有新请求产生后重新验证数据，适用于不经常更改且新鲜度不那么重要的数据。
---
基于时间
```javascript
// 每小时重新验证
fetch('https://...', { next: { revalidate: 3600 } })
```
基于路径
```javascript
// layout.jsx / page.jsx / route.js
export const revalidate = 3600
```
2. 一种是按需重新验证，，根据事件手动重新验证数据。按需重新验证又可以使用基于标签（tag-based）和基于路径（path-based）两种方法重新验证数据。适用于需要尽快展示最新数据的场景。
---
路由处理程序或 Server Actions 中，用于手动清除特定路径中的缓存数据(简单来说就是事件触发)
```javascript
revalidatePath('/')
```
revalidateTag 依赖的是 Next.js 的缓存标签系统，当使用 fetch 请求的时候，声明一个标签，然后在路由处理程序或是 Server Actions 中重新验证具有某一标签的请求：
```javascript
// 使用标签
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```
```javascript
// 重新验证具有某一标签的请求
revalidateTag('a')
```
## 总结
- 请求记忆是 React 的数据缓存方案，它只持续在组件树渲染期间，目的是为了避免组件树渲染的时候多次请求同一数据造成的性能影响。

- 数据缓存是 Next.js 的数据缓存方案，它可以跨部署和请求缓存，缓存数据不会失效，除非重新验证或者主动退出。目的在于优化应用性能。

- 实际项目开发的时候，请求记忆和数据缓存往往同时存在，共同作用。