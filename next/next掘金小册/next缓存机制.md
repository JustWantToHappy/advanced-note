## 四种缓存机制
|机制|缓存内容|存储地方|目的|期间|
|----|----|----|----|----|
|请求记忆|函数返回值|服务端|在React组件树中服用数据|每个请求的生命周期|
|数据缓存|数据|服务端|跨用户请求和部署复用数据|持久(可重新验证)|
|完整路由缓存|HTML和RSC payload|服务端|降低渲染成本、提高性能|持久(可重新验证)|
|路由缓存|RSC payload|客服端|减少导航时的服务端请求|用户会话或基于时间|
## 请求记忆
### 工作原理
React扩展了fetch API,当有多个相同的URL和参数的时候，React会自动将请求结果缓存，也就是说，即使你在组件树中的多个位置请求了同一份数据，但是数据的获取只会执行一次<br><br>
这样当你跨路由(比如跨布局、页面、组件)的时候，你无需在顶层请求数据，然后将结果通过Context或者props的方式传递给子组件，直接在需要数据的组件中请求数据即可，无需担心同一数据发出多次请求造成的性能问题<br><br>
关于请求记忆需要关注的点:
- 请求记忆是React的特性，并非next.js的特性，React.js和Next.js都做了请求缓存
- 请求记忆只适合GET方法的fetch请求
- 请求记忆只应用于React组件树，也就是说你在 generateMetadata、generateStaticParams、布局、页面和其他服务端组件中使用 fetch 会触发请求记忆，但是在路由处理程序中使用则不会触发，因为这就不在 React 组件树中了
> 说人话，我觉得就是next层面的React集成了了类似swr的功能
